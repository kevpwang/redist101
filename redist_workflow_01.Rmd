---
title: "redist 101 - redist workflow 01"
author: "Sho Miyazaki"
date: "2022-09-16"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(width = 100)
library(tidyverse)
library(alarmdata)
library(redist)
```

# Overview of building data objects

## `redist_map` 
The first step one in a `redist` analysis is creating the `redist_map` object, which stores the basic parameters of the redistricting problem. 
Here, we use the `redist_map` objects that can be downloaded from `alarmdata` package.
```{r message=FALSE}
map_nc <- alarm_50state_map("NC")
print(map_nc)
```
As it shows above, `redist_map` (and shapefiles) looks like an dataframe with many columns, such as populations and geographical information. 

For example, the `geometry` column contains the geographic shapefile information, which can be mapped as `POLYGON` (or `MULTIPOLYGON`) shape of the geographical area. 

```{r}
head(map_nc$geometry)
```

## Shapefiles and Projections
If you want to use the other shapefile data for the redistricting analysis (other countries, etc.), you need to transform the available shapefiles (census data, etc.) into the `redist_map` objects using [`redist_map()` function](https://alarm-redist.org/redist/reference/redist_map.html). 

As there are multiple formats of [shapefiles](https://r-spatial.github.io/sf/), you may also need to convert and adjust them into a unified format. 
For example, projections must be in the same style. For more information, check pp.17-18 of [this presentation for the workshop](https://docs.google.com/presentation/d/1FlTfDv8sjhDxxU2KIOnKd1SHhvivm7WdD0bYdrNNgo0/edit#slide=id.g11d65f9e588_0_0). 

## Adjacency List
Since the legislative district plans are generally required to be contiguous, all the `redist` simulation algorithms operate on an *adjacency graph*, which is constructed from the actual precinct or county geography.

What is adjacency? -- It is the formalization of contiguity. 

Then, what does contiguity means? -- Two units are adjacent if they are contiguous geographically. 

Let’s check what the adjacency list looks like.
The `adj` column of `redist_map` is the adjacency list. 

```{r}
head(map_nc$adj)
```

As you can see, the adjacency list shows that the area (row-wise) is adjacent/contiguous to which areas. 

With the `redist_map` object, we can plot this adjacency list. 
```{r}
plot(map_nc, adj=TRUE)
```

You may need to (fix the adjacency list manually)] with [`geomander` package](https://christophertkenny.com/geomander/reference/add_edge.html), particularly when there are islands connected with bridge. 

## Further Pre-processing
Often, we want to only analyze a portion of a map, or hold some districts fixed while others are re-simulated. We may also want to implement a status-quo-type constraint that encourages simulated districts to be close to a reference plan. This can be accomplished by freezing the “cores” of each district.

All of these operations fall under the umbrella of map pre-processing, and `redist` is well-equipped to handle them.  

The map [pre-processing vignette](https://alarm-redist.org/redist/articles/map-preproc.html) contains more information and examples about these operations.


# Simulating redistricting plans

## Sampling Algorithms
As discussed above, we want to create counterfactual plans by obtaining a representative sample with the algorithms. 
The `redist` package has three functions that use Sequential Monte Simulations (`redist_smc`) and Markov Chain Monte Carlo (`redist_flip` and `redist_mergesplit`) algorithms.
In this section, we will pick up `redist_smc`, which generates nearly independent congressional or legislative redistricting plans according to contiguity, population, compactness, and administrative boundary constraints.
For the details of the functions, check the following.

* [`redist_smc`](https://alarm-redist.org/redist/reference/redist_smc.html)
* [`redist_flip`](https://alarm-redist.org/redist/reference/redist_flip.html) and 
*[`redist_mergesplit`](https://alarm-redist.org/redist/reference/redist_mergesplit.html) 

## `redist_smc`
Once the `redist_map` is ready, we can run the simple simulations. 
Here, let's try generating five hundred simulated plans for North Carolina. Note that we can ask `redist_smc` to produce five hundred plans by combining two separate simulation runs. This ensures that the algorithm "converges"--that is, that the distribution of plans we obtain is stable.

```{r}
smc_plans_basic <- redist_smc(map_nc, nsims = 250, runs = 2L)
```

Now, you have got 500 plans. The output of the simulations is `redist_plans` format. The followings are the first six plans generated by the simulations, and you can plot them. 

```{r}
redist.plot.plans(smc_plans_basic, draws=1:6, shp=map_nc)
```

Using the `summary` function, we can perform a diagnostic check to ensure that our plans have converged and are diverse (in other words, that we are exploring a sufficient space of possible alternative plans, rather than simulating the same plan over and over again).

```{r}
summary(smc_plans_basic)
```

## Constraints

The simulation output from the SMC is unbiased random sample, but not always mean representative.
Since each state (or equivalent) has a different legal requirements for the redistricting plan, representative sample has to be in the resemble the space of legal possibilities. 
Thus, we need to customize the constraints to operationalize legal requirements and norms. 
For example, in some cases, each district has to have an equal population, while the margins of tolerance exist, which can be varied by the state. To adjust to that rule, we can customize the constraints as you can see below. 
In `redist`, you can add both *hard* and *soft* constraints.

### Hard Constraits
* Population Tolerance (`pop_tol`= 0.0x) -- all plans must be within x% of population equality.
* Contiguity -- all plans must be contiguous 
* County splits -- all plans must have up to a small number of splits

### Soft constraints
* `redist` allows you to add soft constraints that are listed [here](https://alarm-redist.org/redist/reference/constraints.html). 
* Using [`add_constr_xyz()`](https://alarm-redist.org/redist/reference/constraints.html) (`xyz` varies depending on the constraints you want to add) functions, you can add constraints on the redistricting process to be encoded in the target distribution for sampling of `redist_smc()` and `redist_mergesplit()`. 
* Note that higher and higher strength values will eventually cause the algorithm's accuracy and efficiency to suffer. Whenever you use constraints, be sure to check all sampling diagnostics.
  
### Example
#### Change Population Tolerance
You can use `get_pop_tol()` function to check the current population tolerance of `redist_map` object.

```{r}
get_pop_tol(map_nc)
```
As you can see above, the population tolerance of `map_nc` is `r get_pop_tol(map_nc)`.
This means that all plans must be within `r 100*get_pop_tol(map_nc)`% of population equality.
This is why you can see the output message of `redist_smc()` shows following.
```{r}
redist_smc(map_nc, 10)
```
As you can see, all the `total_pop` should be within between 741,942 and 749,399, which is `r 100*get_pop_tol(map_nc)`% of population equality.

Then, let's change the population tolerance with `set_pop_tol()` function. Here, we will set `pop_tol` into 0.05 (5%).
```{r}
map_nc_constr <- set_pop_tol(map_nc, 0.05)
redist_smc(map_nc_constr, 10)
```
Now, as the population tolerance changes, the possible range of `total_pop` expanded between 708,387 and 782,954. 

#### Fewer County Splits
We can also add a soft constraints to the simulation. 
Here, we will try to add a constraint that prefers the fewer county splits by creating `redist_constr` object.
```{r}
constr <- redist_constr(map_nc_constr)
constr <- add_constr_splits(constr, strength = 1.5, admin = county)
smc_plans_constr <- redist_smc(map = map_nc,
                               nsims = 500,
                               constraints = constr)
```

### `redist_plans` output
Changing the constraints means changing the output sample of the simulations. 
Although we are going to explain in detail how to evaluate and analyze the simulation output with certain measures, here let’s see how the constraints changed the population deviation of the simulation outcome.
```{r fig.show="hold", out.width="50%", fig.align='center'}
# original constraints
group_by(smc_plans_basic, draw) %>%
  summarize(pop_dev = max(abs(total_pop/mean(total_pop) - 1))) %>%
  redist.plot.hist(pop_dev, bins = 10) +
  xlim(c(0.003, 0.0055))

# customized constraints
group_by(smc_plans_constr, draw) %>%
  summarize(pop_dev = max(abs(total_pop/mean(total_pop) - 1))) %>%
  redist.plot.hist(pop_dev, bins = 10) +
  xlim(c(0.003, 0.0055))
```

